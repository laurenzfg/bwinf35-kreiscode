\section{Lösungsidee}
Um möglichst effizient Kreismittelpunkte zu bestimmen, mache ich mir zunächst folgende Eigenschaft von Kreisen zunutze: Am Mittelpunkt eines Kreises ist der Abstand (Radius) zu der äußeren Linie des Kreises in jede Richtung gleich (s. Grafik).

\begin{figure}[!ht]
	\centering	
	\includegraphics[width=0.8\textwidth]{durchmesservergleich}
	\caption{Versch. Formen mit eingezeichnetem Mittelpunkt (erstes Kriterium)}
\end{figure}

In einem Bild lassen sich solche Punkte finden, indem man von jedem schwarzen Bildpunkt den Abstand in vertikale wie horizontale Richtung misst und miteineander vergleicht. Von einem Vergleich des Abstandes in andere Richtungen (z.B. diagonal) sollte man bei einem Bild aus Pixeln absehen, da bei der Speicherung eines Kreises als Bitmap aus quadratischen Pixeln diagonale Messungen oder gar Messungen unter beliebigem Winkel ungenaue Ergebnisse liefern. Diagonale Messungen sind zwar prinzipiell möglich, liefern aber anders als vertikale oder horizontale Messungen kein ganzzahliges Ergebnis, da eine Pixeldiagonale \(\sqrt{2}\) Pixelseiten lang ist.

Da diese Bedingung jedoch auch Punkte in Quadraten und anderen unregelmäßigen Formen liefert, muss für eine zuverlässige Erkennung eine zweite Eigenschaft von Kreisen genutzt werden: Bei bekanntem Durchmesser kann die Fläche eines Kreises mit der Kreisformel bestimmt werden. Diese Soll-Fläche kann mit der tatsächlichen Fläche verglichen werden. Sollte das Delta zwischen diesen beiden Flächengrößen nahe 0 sein, handelt es sich mit großer Wahrscheinlichkeit um einen Kreismittelpunkt. In meiner Implementierung muss das Delta zwischen der Ist- und Soll-Fläche kleiner als 5\% sein.

\begin{wrapfigure}{r}{0.35\textwidth}
  \centering
  \includegraphics[width=0.33\textwidth]{dims}
  \caption{Größenverhältnisse}
\end{wrapfigure}
Danach gilt es noch zu bestimmen, ob es sich bei dem Kreis um einen Mittelpunkt eines \task{}s handelt, schließlich sollen sonstige Kreise im Bild nicht ausgegeben werden. Hierzu können wir uns die Proportionen eines \task{s} zu nutze machen: Nach der Kreisaußenseite folgt ein leerer Raum mit der Länge von \(\frac{1}{3}d\), gefolgt von einer ebenso langen durchgehend schwarzen Stelle. Daraus folgt, dass jeder vom Mittelpunkt um \(d\) verschobene Punkt im Kreisring liegen muss. (s. Abbildung).

Nun können wir den Mittelpunkt um  \(d\) nach rechts, links, oben und unten verschieben. Dort können wir die Länge der entsprechenden Zusammenhangskomponente mit dem Soll \(\frac{1}{3}d\) vergleichen. Weitere Messungen würden die Laufzeit des Algorithmusses erhöhen, die Wahrscheinlichkeit eines False Positives ist nach Durchlaufen dieser drei Kriterien sehr gering. Die Erkennungsrate liegt im Beispielbild bei 100\%.

\textbf{Idee: Nochmal so eine coole FloodFill um die Juroren zu beeindrucken oso}
\section{Umsetzung}
Zunächst implementierte ich mithilfe von ImageIO eine Bildeinleseprozedur. Da ImageIO nur RGB-JP(E)Gs, PNGs, BMPs und GIFs einlesen kann, habe ich einen Wrapper für ImageMagick\footnote{\url{http://www.imagemagick.org/}, GPLv3-kompatible freie Lizenz. Enthalten in den Repositories der gängigen Linux-Distributionen, Binarys für weitere Betriebssysteme auf der Entwicklerseite.} geschrieben. Wenn dieser über die entsprechende Checkbox in der GUI zugeschaltet wird, können alle gängigen Bildformate gelesen werden. Nachteil ist eine deutlich längere Einlesezeit. Außerdem muss ImageMagick lokal installiert sein und mit dem Befehl \texttt{convert} aufrufbar sein.\footnote{Getestet unter Arch Linux und Ubuntu Linux 16.10. Weitere Betriebssysteme werden vermutlich auch unterstützt.}

Zunächst überlegte ich mir eine möglichst effiziente Datenstruktur für Grafiken, da die Interaktion über ImageIO mit Bitmaps nicht sonderlich effizient ist. Da für die Erkennung von Kreisen in einer Grafik genaue Informationen über die Farbe eines Bildpunktes nicht relevant sind, kann das Bild beim Einlesevorgang in ein boolesches 2D-Array überführt werden: In diesem Array, das die gleiche Größe wie das eingelesene Bild besitzt, sind die Bildpunkte als True gespeichert, die Teil eines \task{}s sein könnten. In der in Teilaufgabe 1 gegebenen Schwarz-Weiß-Grafik ist diese Einstufung noch simpel: Schwarze Bildpunkte können Teil eines \task{}s sein, sonstige nicht.

Um in diesem Array die Punkte zu bestimmen, deren Kreisradien sich in alle vier Richtungen gleichen, muss zunächst die Länge von aufeinanderfolgenden Streifen aus möglichen \task{}-Feldern ermittelt werden. Diese nenne ich nun lineare Zusammenhängigkeitskomponenten. In seperaten Arrays für horizontale und vertikale Streifen speichere ich für jedes Feld die Länge seiner linearen Zusammenhängigkeitskomponente. Für ein mögliches \task{}-Feld liegt diese für horizontale Zusmmenhängikeitskomponenten bei \(1 \le l \le width\), für vertikale entsprechend bei
\(1 \le l \le height\)
. Bei allen Feldern, die kein Teil einer Zusmmenhängikeitskomponente sind, liegt dieser Wert bei 0. 

Danach kann für jede Koordinate die horizontale und vertikale Zusammenhängigkeitskomponentenlänge verglichen werden. Gleichen sie sich, handelt es sich um einen möglichen Mittelpunkt. Von diesem Punkt aus kann die Soll-Fläche mit der Kreisformel berechnet werden, denn derer Durchmesser des Kreises ist nun mit der Länge einer der beiden Zusammenhängigkeitskomponenten gegeben. Die tatsächliche Länge der Fläche kann mit einer Flood-Fill ermittelt werden.

Schließlich muss noch das Vorhandensein des Kreisringes wie in der Lösungsidee beschrieben verifiziert werden. Auch hier akzeptiert das Programm eine Abweichung im Mittel von 5\%, da durch Anti-Aliasing oder Unschärfen bei der Bildaufnahme Abweichungen vom mathematischen Ideal der Spezifikation zwangsläufig auftreten.
% TODO: Mehrere Punkte wegen kack Anti-Aliasing

\pagebreak
\section{Beispiele}
Die erkannten Kreismittelpunkte sind mit violetten Kreuzen markiert.
\begin{figure}[!ht]
	\centering	
	\includegraphics[width=\textwidth]{sek1bsp1}
	\caption{Beispielbild d. Aufgabenstellung}
\end{figure}